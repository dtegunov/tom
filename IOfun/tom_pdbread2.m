function pdb_out=tom_pdbread2(pdbfile,varargin)
%PDBREAD reads a pdb
%
%   PDBSTRUCT = PDBREAD(PDBFILE) reads in a PDB coordinate entry file
%   
%   PDBREAD(PDBFILE,'MODELNUM',M) reads only the coordinate information of
%   the M-th model and all other sections of the PDBFILE. If M does not
%   correspond to an existing model serial number in the PDBFILE the whole
%   file is read.
%
%  
%   Examples:
%
%       % Get the Green Fluorescent Protein PDB data and save it to a file.
%       gfl = getpdb('1GFL','TOFILE','1gfl.pdb');
% 
%       % Then read it into MATLAB
%       gfl = pdbread('1gfl.pdb')
% 
%       % Read the Green Fluorescent Protein data from PDB
%       gfl = pdbread('http://www.rcsb.org/pdb/files/1gfl.pdb')
%
%   See also tom_pdbwrite2
%   Reference:

% Validate input data
if nargin < 1
    error('not enough input arguments');
end

% Check pdbfile is a string.
if ~ischar(pdbfile)
    error('wrong input');
end

% Get PDB filename
useTempFile = true;
if exist(pdbfile,'file');
    filename = pdbfile;
    useTempFile = false;
elseif ~isempty(pdbfile) && ~isempty(strfind(pdbfile(1,:),'HEADER')) && ~isempty(strfind(pdbfile(end,:),'END'))
    filename = savetempfile(pdbfile);
elseif (strfind(pdbfile, '://'))
    if (~usejava('jvm'))
        error(message('bioinfo:pdbread:NoJava'))
    end
    % Must be a URL
    pdbfile = urlread(pdbfile);
    % Clean up any &amp s
    pdbfile=strrep(pdbfile,'&amp;','&');
    filename = savetempfile(pdbfile);
else
    error(message('bioinfo:pdbread:BadPDBFile'))
end

modelNum = 0;
if  nargin > 1
    if rem(nargin,2) ~= 1
        error(message('bioinfo:pdbread:IncorrectNumberOfArguments', mfilename));
    end
    okargs = {'modelnum'};
    for j=1:2:nargin-1
        pname = varargin{j};
        pval = varargin{j+1};
        k = find(strncmpi(pname,okargs,numel(pname)));
        if isempty(k)
            error(message('bioinfo:pdbread:UnknownParameterName', pname));
        elseif length(k)>1
            error(message('bioinfo:pdbread:AmbiguousParameterName', pname));
        else
            switch(k)
                case 1  % model number
                    modelNum = pval;
                    if ~isnumeric(modelNum) || numel(modelNum)> 1 || isempty(modelNum) || modelNum < 0
                        error(message('bioinfo:pdbread:BadModelNumber'))
                    end
            end
        end
    end
end

% Open file
fid = fopen(filename,'r');

if fid == -1,
    if ~useTempFile
        error(message('bioinfo:pdbread:CouldNotOpenFile', filename));
    else
        error(message('bioinfo:pdbread:CouldNotOpenTempFile', filename));
    end
end

theLines = textscan(fid,'%s','delimiter','\n');
theLines = theLines{1};
fclose(fid);

if useTempFile
    delete(filename);
end

% Remove the lines corresponding to other models when requested a
% particular model
if modelNum ~= 0
    modelStarts = find(strncmp(theLines,'MODEL ',6));
    modelEnds = find(strncmp(theLines,'ENDMDL ',7));
    modelMatch = ['^MODEL \s*' num2str(modelNum) '\s'];
    h = find(~cellfun(@isempty,regexp(theLines(modelStarts),modelMatch,'once')));
    if isempty(h)
       warning(message('bioinfo:pdbread:NoModelEntry', modelNum));
    else
       q = [1:modelStarts(1)-1 modelStarts(h):modelEnds(h) modelEnds(end)+1:numel(theLines)];
       theLines = theLines(q);
    end
end


%---  Initialize structure and variables

pdb_out = [];

% Following are some of the initializations necessary for various
% record types mentioned in the comments
% This is the count for the number of the JRNL records in the PDB file
Journal_Entry = 1;
% The array of flags for the subrecords. JRNLSubRecords(1)=AUTH,
% JRNLSubRecords(2)=TITL, JRNLSubRecords(3)=EDIT
%                                        JRNLSubRecords(4)=REF,
%                                        JRNLSubRecords(5)=PUBL ,
%                                        JRNLSubRecords(6)=REFN
%     JournalSubRecords = zeros(1,6);
%     OldNumKeywds = 0; % KEYDS
%     OldNumEntries = 0; % OBSLTE
%     OldNumAuthors = 0; % AUTHOR
NumOfRevisionDate = 0; % REVDAT
NumOfDBReferences = 0; % DBREF
NumOfSequenceConflicts = 0; % SEQADV
NumOfModifiedResidues = 0; % MODRES
NumOfHeterogen = 0; % HET
NumOfHeterogenName = 0; % HETNAM
NumOfHelix = 0; % HELIX
NumOfSheet = 0; % SHEET
NumOfTurn = 0; %TURN
NumOfSSBond = 0; % SSBOND
NumOfLink = 0; % LINK
NumOfHydrogenBond = 0; % HYDBND
NumOfSaltBridge =0; % SLTBRG
NumOfCISPeptides = 0; % CISPEP
NumOfTranslationVector = 0; % TVECT
NumOfConnectivity = 0; % CONECT
NumOfAtomSD = 0; % SIGATM
NumOfAnisotropicTemp = 0; % ANISOU
NumOfAnisotropicTempSD = 0; % SIGUIJ
NumOfAtom = 0; % Atom
NumOfHeterogenSynonym = 0; % HETSYN
NumOfFormula = 0; % FORMUL
NumOfHeterogenAtom = 0; % HETATM
NumOfModel = 0; % MODEL
NumOfTerminal = 0; % TER
NumResChain = 0;
JournalAuth = 0;
ModelSerNum = 1;
PrevRes = '';
PrevSiteName = '';
PrevHetIDHeterogenSynonym = '';
PrevHetIDFormula = '';
PrevHetIDHeterogenName = '';
PrevRemark = 0;
PrevFtnote = 0;

% This is for SITE record
TmpStruct = struct('ResName',{},'ChainID',{''},'ResSeqNo',{},'InsCode',' ');
TmpAtomStruct = allocateAtoms;
TmpTerStruct = allocateTerminal;
TmpHetStruct = allocateAtoms;
TmpAtomSDStruct = allocateAtomSD;
TmpAnisoTempStruct = allocateAnisoTemp;
TmpAnisoTempSDStruct = allocateAnisoTempSD;

% these flags are used for every model
modelWithAtom = false;
modelWithHetAtom = false;
modelWithTerminal = false;
modelWithAtomSD = false;
modelWithAnisoTemp = false;
modelWithAnisoTempSD = false;


numLines = numel(theLines);
lineCounter = 1;
blank = blanks(80);

while lineCounter <= numLines
    tline = theLines{lineCounter};
    lineCounter = lineCounter+1;
    if ~ischar(tline)
        break; % For end of file recognition
    end
    len = length(tline);
    if len == 0 % Omit the empty lines to avoid error of invalid matrix index.
        continue
    end
    
    % RCSB web site format requires each line to have 80 characters. This
    % avoids exceeding the matrix dimension for lines with
    tline = [tline blank(len+1:80)]; 
    % Less than 80 characters. 
    Record_name = upper(tline(1:6));
    % Assuming that the record name will be left aligned (as mentioned in
    % the RCSB file format doc,remove trailing blanks
    Record_name = deblank(Record_name); 
    
    % This is done to take care of ORIGX1,ORIGX2,ORIGX3 and similarly for
    % SCALE and MTRIX
    if strncmp(Record_name,'ORIGX',5) || strncmp(Record_name,'SCALE',5) || strncmp(Record_name,'MTRIX',5) 
        Record_name = Record_name(1:5);
    end

    switch Record_name
        case 'HEADER' %Single/Mandatory
            pdb_out.Header = struct('classification',{deblank(tline(11:50))},...
                                       'depDate',{tline(51:59)},...
                                       'idCode',{tline(63:66)});
                                   
        case 'OBSLTE' % Single Continued/Optional : mandatory in withdrawn entries
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Obsolete = struct('repDate',{tline(12:20)},...
                                             'idCode',{tline(22:25)},...
                                             'rIdCode',{strtrim(tline(32:70))});
            else
                pdb_out.Obsolete.rIdCode = strvcat(pdb_out.Obsolete.rIdCode,...
                                                      strtrim(tline(32:70))); %#ok
            end
            
        case 'TITLE'%Single Continued/Mandatory
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Title = strtrim(tline(11:70));
            else
                pdb_out.Title = strvcat(pdb_out.Title,strtrim(tline(11:70))); %#ok
            end
            
        case 'CAVEAT' %Single Continued/Optional
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Caveat =  struct('idCode',{tline(12:15)},'comment',{strtrim(tline(20:70))});
            else
                pdb_out.Caveat.comment = strvcat(pdb_out.Caveat.comment,strtrim(tline(20:70))); %#ok
            end

        case 'COMPND' %Single Continued/Mandatory
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Compound = strtrim(tline(11:70));
            else
                pdb_out.Compound = strvcat(pdb_out.Compound,strtrim(tline(11:70))); %#ok
            end

        case 'SOURCE' %Single Continued/Mandatory
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Source = strtrim(tline(11:70));
            else
                pdb_out.Source = strvcat(pdb_out.Source,strtrim(tline(11:70))); %#ok
            end

        case 'KEYWDS' %Single Continued/Mandatory
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Keywords = strtrim(tline(11:70));
            else
                pdb_out.Keywords = strvcat(pdb_out.Keywords,strtrim(tline(11:70))); %#ok
            end

        case 'EXPDTA' %Single Continued/Mandatory
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.ExperimentData = strtrim(tline(11:70));
            else
                pdb_out.ExperimentData = strvcat(pdb_out.ExperimentData,...
                                                    strtrim(tline(11:70))); %#ok
            end

        case 'AUTHOR' %Single Continued/Mandatory
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Authors = strtrim(tline(11:70));
            else
                pdb_out.Authors = strvcat(pdb_out.Authors,strtrim(tline(11:70))); %#ok
            end

        case 'REVDAT' %Multiple Continued/Mandatory

                NumOfRevisionDate = NumOfRevisionDate+1;
                pdb_out.RevisionDate(NumOfRevisionDate) =...
                    struct('modNum',{str2double(tline(8:10))},...
                           'modDate',{tline(14:22)},...
                           'modId',{tline(24:28)},...
                           'modType',{str2double(tline(32))},...
                           'record',{strtrim(tline(40:66))});

        case 'SPRSDE' %Single Continued/Optional
            if strcmp(tline(9:10),'  ') %check for continuation
                pdb_out.Superseded = struct('Supersededdate',{tline(12:20)},...
                                               'idCode',{tline(22:25)},...
                                               'sIdCode',{strtrim(tline(32:70))});
            else
                pdb_out.Superseded.sIdCode =...
                    strvcat(pdb_out.Superseded.sIdCode,strtrim(tline(32:70))); %#ok
            end
        case 'JRNL' %Other/Optional : This record has following sub-records: AUTH,TITL,EDIT,REF,PUBL,REFN
            SubRecord = tline(13:16);
            SubRecord = deblank(SubRecord); % Remove the trailing blanks. Needed for REF

            switch SubRecord
                case 'AUTH'
                    if ~JournalAuth
                        JournalAuth = 1;
                        pdb_out.Journal(Journal_Entry) = struct('Author',{''},...
                                                                   'Title',{''},...
                                                                   'Editor',{''},...
                                                                   'Reference',{''},...
                                                                   'Publisher',{''},...
                                                                   'CitationReference',{''});
                        pdb_out.Journal(Journal_Entry).Author =...
                            strvcat(pdb_out.Journal(Journal_Entry).Author,strtrim(tline(20:70))); %#ok
                    else
                        pdb_out.Journal(Journal_Entry).Author =...
                            strvcat(pdb_out.Journal(Journal_Entry).Author,strtrim(tline(20:70))); %#ok
                    end

                case 'TITL'
                    pdb_out.Journal(Journal_Entry).Title =...
                        strvcat(pdb_out.Journal(Journal_Entry).Title,strtrim(tline(20:70))); %#ok

                case 'EDIT'
                    pdb_out.Journal(Journal_Entry).Editor = ...
                        strvcat(pdb_out.Journal(Journal_Entry).Editor,strtrim(tline(20:70))); %#ok

                case 'REF'
                    pdb_out.Journal(Journal_Entry).Reference = ...
                        strvcat(pdb_out.Journal(Journal_Entry).Reference,strtrim(tline(20:70))); %#ok

                case 'PUBL'
                    pdb_out.Journal(Journal_Entry).Publisher = ...
                        strvcat(pdb_out.Journal(Journal_Entry).Publisher,strtrim(tline(20:70))); %#ok

                case 'REFN'
                    pdb_out.Journal(Journal_Entry).CitationReference = ...
                        strvcat(pdb_out.Journal(Journal_Entry).CitationReference,tline(20:70)); %#ok
                    % REFN is the last subrecord and it is a single line record
                    Journal_Entry = Journal_Entry+1; 
                    JournalAuth = 0;

                otherwise
                    %disp('Invalid subrecord type');
            end

            % Some of the Remark records are mandatory and some are optional
        case 'REMARK'
            RemarkNo = str2double(tline(7:10));

            %Other/Optional
            if RemarkNo == 1
                CurRemark = RemarkNo;
                if CurRemark ~= PrevRemark
                    pdb_out.Remark1 = '';
                    PrevRemark = CurRemark;
                end
                if strcmp(tline(12:20),'REFERENCE')
                    pdb_out.Remark1.NumJournals = str2double(tline(22:70));
                    pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals) = ...
                        struct('Author',{''},...
                        'Title',{''},...
                        'Editor',{''},...
                        'Reference',{''},...
                        'Publisher',{''},...
                        'CitationReference',{''});
                else
                    SubRecord = tline(13:16);
                    SubRecord = deblank(SubRecord); % Remove the trailing blanks. Needed for REF

                    switch SubRecord

                        case 'AUTH'
                            pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Author = ...
                                strvcat(pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Author,...
                                strtrim(tline(20:70))); %#ok

                        case 'TITL'
                            pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Title = ...
                                strvcat(pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Title,...
                                strtrim(tline(20:70)));  %#ok

                        case 'EDIT'
                            pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Editor = ...
                                strvcat(pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Editor,...
                                strtrim(tline(20:70)));  %#ok

                        case 'REF'
                            pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Reference = ...
                                strvcat(pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Reference,...
                                strtrim(tline(20:70)));  %#ok

                        case 'PUBL'
                            pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Publisher = ...
                                strvcat(pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).Publisher,...
                                strtrim(tline(20:70)));  %#ok

                        case 'REFN'
                            pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).CitationReference = ...
                                strvcat(pdb_out.Remark1.JournalEntry(pdb_out.Remark1.NumJournals).CitationReference,...
                                strtrim(tline(20:70)));  %#ok

                        otherwise
                            %disp('Invalid subrecord type');
                    end
                end
            elseif RemarkNo == 2 % Other/Mandatory
                CurRemark = RemarkNo;
                if CurRemark ~= PrevRemark
                    pdb_out.Remark2 = '';
                    PrevRemark = CurRemark;
                end
                if strcmp(tline(12:22),'RESOLUTION.')

                    if strcmp(tline(29:38),'ANGSTROMS.')
                        pdb_out.Remark2.Resolution = str2double(tline(23:27));
                    else
                        pdb_out.Remark2.Detail = strtrim(tline(12:70)); 
                    end

                else
                    if isequal(tline(12:22),blanks(11))
                        pdb_out.Remark2.Detail = '';
                    else
                        pdb_out.Remark2.Detail = ...
                            strvcat(pdb_out.Remark2.Detail, strtrim(tline(12:70)));  %#ok
                    end
                end
                pdb_out.Remark3.Refinement = '';

                % Other/Mandatory:  Following code assumes a single
                % occurrence of the Remark3 record type
            elseif RemarkNo == 3
                CurRemark = RemarkNo;
                if CurRemark ~= PrevRemark
                    pdb_out.Remark3.Refinement = '';
                    PrevRemark = CurRemark;
                else
                    pdb_out.Remark3.Refinement = ...
                        strvcat(pdb_out.Remark3.Refinement,tline(12:70)); %#ok
                end

                % Other/Optional
            else
                CurRemark = RemarkNo;
                tmpRemark = sprintf('%d',CurRemark);

                if CurRemark ~= PrevRemark
                    pdb_out.(['Remark' tmpRemark]) = tline(12:70);
                    PrevRemark = CurRemark;
                else
                    pdb_out.(['Remark' tmpRemark])  = ...
                        strvcat(pdb_out.(['Remark' tmpRemark]) ,tline(12:70)); %#ok
                end


            end

        case 'DBREF'%Multiple/Optional
            NumOfDBReferences = NumOfDBReferences+1;
            pdb_out.DBReferences(NumOfDBReferences) = ...
                struct('idCode',{tline(8:11)},...
                       'chainID',{tline(13)},...
                       'seqBegin',{str2double(tline(15:18))},...
                       'insertBegin',{tline(19)},...
                       'seqEnd',{str2double(tline(21:24))},...
                       'insertEnd',{tline(25)},...
                       'database',{tline(27:32)},...
                       'dbAccession',{tline(34:41)},...
                       'dbIdCode',{tline(43:54)},...
                       'dbseqBegin',{str2double(tline(56:60))},...
                       'idbnsBeg',{tline(61)},...
                       'dbseqEnd',{str2double(tline(63:67))},...
                       'dbinsEnd',{tline(68)});
            
        case 'SEQADV'%Multiple/Optional
            NumOfSequenceConflicts = NumOfSequenceConflicts+1;
            pdb_out.SequenceConflicts(NumOfSequenceConflicts) = ...
                struct('idCode',{tline(8:11)},...
                       'resName',{tline(13:15)},...
                       'chainID',{tline(17)},...
                       'seqNum',{str2double(tline(19:22))},...
                       'iCode',{tline(23)},...
                       'database',{tline(25:28)},...
                       'dbIdCode',{tline(30:38)},...
                       'dbRes',{tline(40:42)},...
                       'dbSeq',{str2double(tline(44:48))},...
                       'conflict',{strtrim(tline(50:70))});
           
        case 'SEQRES' %Multiple/Optional
            if isspace(tline(12))
                CurRes = sprintf('%d',str2double(tline(14:17)));
            else
                CurRes = tline(12);
            end

            if ~isequal(CurRes,PrevRes)
                NumResChain = NumResChain + 1;
                pdb_out.Sequence(NumResChain).NumOfResidues = str2double(tline(14:17));
                pdb_out.Sequence(NumResChain).ChainID = tline(12);
                pdb_out.Sequence(NumResChain).ResidueNames = tline(20:70);
                pdb_out.Sequence(NumResChain).Sequence = strtrim(GetSequence(tline(20:70)));
                PrevRes = CurRes;
            else
                pdb_out.Sequence(NumResChain).ResidueNames = ...
                    strcat(pdb_out.Sequence(NumResChain).ResidueNames,[' ',tline(20:70)]);
                pdb_out.Sequence(NumResChain).Sequence = ...
                    strcat(pdb_out.Sequence(NumResChain).Sequence,GetSequence(tline(20:70)));
            end

        case 'MODRES'%Multiple/Optional
            NumOfModifiedResidues = NumOfModifiedResidues+1;
            pdb_out.ModifiedResidues(NumOfModifiedResidues) = ...
                struct('idCode',{tline(8:11)},...
                       'resName',{tline(13:15)},...
                       'chainID',{tline(17)},...
                       'seqNum',{str2double(tline(19:22))},...
                       'iCode',{tline(23)},...
                       'stdRes',{tline(25:27)},...
                       'comment',{strtrim(tline(30:70))});

        case 'HET'%Multiple/Optional
            NumOfHeterogen = NumOfHeterogen +1;
            pdb_out.Heterogen(NumOfHeterogen) = ...
                struct('hetID',{tline(8:10)},...
                       'ChainID',{tline(13)},...
                       'seqNum',{str2double(tline(14:17))},...
                       'iCode',{tline(18)},...
                       'numHetAtoms',{str2double(tline(21:25))},...
                       'text',{strtrim(tline(31:70))});

        case 'HETNAM'%Multiple Continued/Optional
            CurHetIDHeterogenName = tline(12:14);

            if ~strcmp(CurHetIDHeterogenName,PrevHetIDHeterogenName)
                NumOfHeterogenName = NumOfHeterogenName + 1;
                pdb_out.HeterogenName(NumOfHeterogenName).hetID = CurHetIDHeterogenName;
                pdb_out.HeterogenName(NumOfHeterogenName).ChemName = strtrim(tline(16:70));
                PrevHetIDHeterogenName = CurHetIDHeterogenName;
            else
                pdb_out.HeterogenName(NumOfHeterogenName).ChemName = ...
                    strvcat(pdb_out.HeterogenName(NumOfHeterogenName).ChemName,...
                            strtrim(tline(16:70))); %#ok
            end

            %Multiple/Optional
        case 'HETSYN'
            CurHetIDHeterogenSynonym = tline(12:14);

            if ~strcmp(CurHetIDHeterogenSynonym,PrevHetIDHeterogenSynonym)
                NumOfHeterogenSynonym = NumOfHeterogenSynonym+1;
                pdb_out.HeterogenSynonym(NumOfHeterogenSynonym).hetID = CurHetIDHeterogenSynonym;
                pdb_out.HeterogenSynonym(NumOfHeterogenSynonym).hetSynonyms = strtrim(tline(16:70));
                PrevHetIDHeterogenSynonym = CurHetIDHeterogenSynonym;
            else
                pdb_out.HeterogenSynonym(NumOfHeterogenSynonym).hetSynonyms = ...
                    strvcat(pdb_out.HeterogenSynonym(NumOfHeterogenSynonym).hetSynonyms,...
                            strtrim(tline(16:70))); %#ok
            end

            %Multiple Continued/Optional
        case 'FORMUL'
            CurHetIDFormula = tline(13:15);

            if ~strcmp(CurHetIDFormula,PrevHetIDFormula)
                NumOfFormula = NumOfFormula+1;
                pdb_out.Formula(NumOfFormula).CompNo = str2double(tline(9:10));
                pdb_out.Formula(NumOfFormula).hetID = tline(13:15);
                pdb_out.Formula(NumOfFormula).ChemForm = strtrim(tline(19:70));
                PrevHetIDFormula = CurHetIDFormula;
            else
                pdb_out.Formula(NumOfFormula).ChemForm = ...
                    strvcat(pdb_out.Formula(NumOfFormula).ChemForm,strtrim(tline(19:70))); %#ok
            end

            %Multiple/Optional
        case 'HELIX'
            NumOfHelix = NumOfHelix+1;
            pdb_out.Helix(NumOfHelix) = ...
                struct('serNum',{str2double(tline(8:10))},...
                       'helixID',{tline(12:14)},...
                       'initResName',{tline(16:18)},...
                       'initChainID',{tline(20)},...
                       'initSeqNum',{str2double(tline(22:25))},...
                       'initICode',{tline(26)},...
                       'endResName',{tline(28:30)},...
                       'endChainID',{tline(32)},...
                       'endSeqNum',{str2double(tline(34:37))},...
                       'endICode',{tline(38)},...
                       'helixClass',{str2double(tline(39:40))},...
                       'comment',{tline(41:70)},...
                       'length',{str2double(tline(72:76))});

        case 'SHEET'%Multiple/Optional
            NumOfSheet = NumOfSheet+1;
            pdb_out.Sheet(NumOfSheet) = ...
                struct('strand',{str2double(tline(8:10))},...
                       'sheetID',{tline(12:14)},...
                       'numStrands',{str2double(tline(15:16))},...
                       'initResName',{tline(18:20)},...
                       'initChainID',{tline(22)},...
                       'initSeqNum',{str2double(tline(23:26))},...
                       'initICode',{tline(27)},...
                       'endResName',{tline(29:31)},...
                       'endChainID',{tline(33)},...
                       'endSeqNum',{str2double(tline(34:37))},...
                       'endICode',{tline(38)},...
                       'sense',{str2double(tline(39:40))},...
                       'curAtom',{tline(42:45)},...
                       'curResName',{tline(46:48)},...
                       'curChainId',{tline(50)},...
                       'curResSeq',{str2double(tline(51:54))},...
                       'curICode',{tline(55)},...
                       'prevAtom',{tline(57:60)},...
                       'prevResName',{tline(61:63)},...
                       'prevChainId',{tline(65)},...
                       'prevResSeq',{str2double(tline(66:69))},...
                       'prevICode',{tline(70)});

        case 'TURN' %Multiple/Optional
            NumOfTurn = NumOfTurn+1;
            pdb_out.Turn(NumOfTurn) = ...
                struct('seq',{str2double(tline(8:10))},...
                       'turnId',{tline(12:14)},...
                       'initResName',{tline(16:18)},...
                       'initChainId',{tline(20)},...
                       'initSeqNum',{str2double(tline(21:24))},...
                       'initICode',{tline(25)},...
                       'endResName',{tline(27:29)},...
                       'endChainId',{tline(31)},...
                       'endSeqNum',{str2double(tline(32:35))},...
                       'endICode',{tline(36)},...
                       'comment',{tline(41:70)});

            %Multiple/Optional
        case 'SSBOND'
            NumOfSSBond = NumOfSSBond+1;
            pdb_out.SSBond(NumOfSSBond) = ...
                struct('serNum',{str2double(tline(8:10))},...
                       'resName1',{tline(12:14)},...
                       'chainID1',{tline(16)},...
                       'seqNum1',{str2double(tline(18:21))},...
                       'icode1',{tline(22)},...
                       'resName2',{tline(26:28)},...
                       'chainID2',{tline(30)},...
                       'seqNum2',{str2double(tline(32:35))},...
                       'icode2',{tline(36)},...
                       'sym1',{tline(60:65)},...
                       'sym2',{tline(67:72)});

            %Multiple/Optional
        case 'LINK'
            NumOfLink = NumOfLink+1;
            pdb_out.Link(NumOfLink) = ...
                struct('remove1',{tline(13:16)},...
                       'altLoc1',{tline(17)},...
                       'resName1',{tline(18:20)},...
                       'chainID1',{tline(22)},...
                       'resSeq1',{str2double(tline(23:26))},...
                       'iCode1',{tline(27)},...
                       'AtomName2',{tline(43:46)},...
                       'altLoc2',{tline(47)},...
                       'resName2',{tline(48:50)},...
                       'chainID2',{tline(52)},...
                       'resSeq2',{str2double(tline(53:56))},...
                       'iCode2',{tline(57)},...
                       'sym1',{tline(60:65)},...
                       'sym2',{tline(67:72)});

            %Multiple/Optional
        case 'HYDBND'
            NumOfHydrogenBond = NumOfHydrogenBond+1;
            pdb_out.HydrogenBond(NumOfHydrogenBond) = ...
                struct('AtomName1',{tline(13:16)},...
                       'altLoc1',{tline(17)},...
                       'resName1',{tline(18:20)},...
                       'Chain1',{tline(22)},...
                       'resSeq1',{str2double(tline(23:27))},...
                       'ICode1',{tline(28)},...
                       'nameH',{tline(30:33)},...
                       'altLocH',{tline(34)},...
                       'ChainH',{tline(36)},...
                       'resSeqH',{str2double(tline(37:41))},...
                       'iCodeH',{tline(42)},...
                       'name2',{tline(44:47)},...
                       'altLoc2',{tline(48)},...
                       'resName2',{tline(49:51)},...
                       'chainID2',{tline(53)},...
                       'resSeq2',{str2double(tline(54:58))},...
                       'iCode2',{tline(59)},...
                       'sym1',{tline(60:65)},...
                       'sym2',{tline(67:72)});

            %Multiple/Optional
        case 'SLTBRG'
            NumOfSaltBridge = NumOfSaltBridge+1;
            pdb_out.SaltBridge(NumOfSaltBridge) = ...
                struct('AtomName1',{tline(13:16)},...
                       'altLoc1',{tline(17)},...
                       'resName1',{tline(18:20)},...
                       'chainID1',{tline(22)},...
                       'resSeq1',{str2double(tline(23:26))},...
                       'iCode1',{tline(27)},...
                       'AtomName2',{tline(43:46)},...
                       'altLoc2',{tline(47)},...
                       'resName2',{tline(48:50)},...
                       'chainID2',{tline(52)},...
                       'resSeq2',{str2double(tline(53:56))},...
                       'iCode2',{tline(57)},...
                       'sym1',{tline(60:65)},...
                       'sym2',{tline(67:72)});

            %Multiple/Optional
        case 'CISPEP'
            NumOfCISPeptides = NumOfCISPeptides+1;
            pdb_out.CISPeptides(NumOfCISPeptides) = ...
                struct('serNum',{str2double(tline(8:10))},...
                       'ResName1',{tline(12:14)},...
                       'chainID1',{tline(16)},...
                       'seqNum1',{str2double(tline(18:21))},...
                       'icode1',{tline(22)},...
                       'ResName2',{tline(26:28)},...
                       'chainID2',{tline(30)},...
                       'seqNum2',{str2double(tline(32:35))},...
                       'icode2',{tline(36)},...
                       'modNum',{str2double(tline(44:46))},...
                       'measure',{str2double(tline(54:59))});

            %Multiple/Optional
        case 'SITE'
            CurSiteName = tline(12:14);
            if ~isfield(pdb_out,'Site') || isempty(pdb_out.Site)
                ResDetail = struct('ResName',{},...
                                   'ChainID',{''},...
                                   'ResSeqNo',{},...
                                   'InsCode',{''});
                pdb_out.Site.SiteDetail = struct('SeqNo',{0},...
                                                    'SiteName',{''},...
                                                    'NoOfRes',{0},...
                                                    'ResDet',{ResDetail});
                pdb_out.Site.SiteNumber = 0;
            end
            if ~strcmp(CurSiteName,PrevSiteName)
                ResNos = 0;
                pdb_out.Site.SiteNumber = pdb_out.Site.SiteNumber+1;
                pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).SeqNo = ...
                    str2double(tline(8:10));
                pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).SiteName = ...
                    strtrim(tline(12:14));
                pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).NumRes = ...
                    str2double(tline(16:17));
                [pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).ResDet ResNos] = ...
                    GetResidueStruct(TmpStruct,tline(19:61),ResNos);
                PrevSiteName = CurSiteName;
            else
                pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).SeqNo = ...
                    [pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).SeqNo;str2double(tline(8:10))];
                [pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).ResDet ResNos] = ...
                    GetResidueStruct(pdb_out.Site.SiteDetail(pdb_out.Site.SiteNumber).ResDet,...
                    tline(19:61),ResNos);
            end

            %Single/Mandatory
        case 'CRYST1' 
            % Fields in this record: Header(record name), a,b,c (all 3 in
            % Angstrom),alpha,beta,gamma(all 3 in degrees),sGroup,z
            pdb_out.Cryst1=struct('a',{str2double(tline(7:15))},...
                                     'b',{str2double(tline(16:24))},...
                                     'c',{str2double(tline(25:33))},...
                                     'alpha',{str2double(tline(34:40))},...
                                     'beta',{str2double(tline(41:47))},...
                                     'gamma',{str2double(tline(48:54))},...
                                     'sGroup',{tline(56:66)},...
                                     'z',{str2double(tline(67:70))});

            %Single/Mandatory
        case 'ORIGX' 
            %Fields in this record: Header(record name), O[n][1](O11),
            %O[n][2](O12), O[n][3](O13), T[n](T1)
            OrigNum = str2double(tline(6));
            pdb_out.OriginX(OrigNum).On1 = str2double(tline(11:20));
            pdb_out.OriginX(OrigNum).On2 = str2double(tline(21:30));
            pdb_out.OriginX(OrigNum).On3 = str2double(tline(31:40));
            pdb_out.OriginX(OrigNum).Tn = str2double(tline(46:55));

            %Single/Mandatory
        case 'SCALE'
            ScaleNum = str2double(tline(6));
            pdb_out.Scale(ScaleNum).Sn1 = str2double(tline(11:20));
            pdb_out.Scale(ScaleNum).Sn2 = str2double(tline(21:30));
            pdb_out.Scale(ScaleNum).Sn3 = str2double(tline(31:40));
            pdb_out.Scale(ScaleNum).Un = str2double(tline(46:55));

            %Single/Optional: Mandatory if the complete unit must be
            %generated from the given coordinates using
            %non-crystallographic symmetry
        case 'MTRIX'
            Matrix_num = str2double(tline(6));
            pdb_out.Matrix(Matrix_num).SerNo = str2double(tline(8:10));
            pdb_out.Matrix(Matrix_num).Mn1 = str2double(tline(11:20));
            pdb_out.Matrix(Matrix_num).Mn2 = str2double(tline(21:30));
            pdb_out.Matrix(Matrix_num).Mn3 = str2double(tline(31:40));
            pdb_out.Matrix(Matrix_num).Vn = str2double(tline(46:55));
            pdb_out.Matrix(Matrix_num).iGiven = str2double(tline(60));

            %Multiple/Optional
        case 'TVECT'
            NumOfTranslationVector = NumOfTranslationVector+1;
            pdb_out.TranslationVector(NumOfTranslationVector) = ...
                struct('SerNo',{str2double(tline(8:10))},...
                       't1',{str2double(tline(11:20))},...
                       't2',{str2double(tline(21:30))},...
                       't3',{str2double(tline(31:40))},...
                       'text',{tline(41:70)});

            % Group/Optional
        case 'MODEL'
            NumOfModel = NumOfModel+1;
            NumOfAtom = 0;
            NumOfTerminal = 0;
            NumOfHeterogenAtom = 0;
            NumOfAtomSD = 0;
            NumOfAnisotropicTemp = 0;
            NumOfAnisotropicTempSD = 0;
            ModelSerNum = str2double(tline(11:14));
            
            %Multiple/Optional
        case 'ATOM'
            % If there only one model
            if NumOfModel == 0
                NumOfModel = ModelSerNum;
                pdb_out.Model = [];
            end
            modelWithAtom = true;
            NumOfAtom = NumOfAtom+1;
                TmpAtomStruct(NumOfAtom) = ...
                struct('AtomSerNo',{str2int(tline(7:11))},...
                       'AtomName',{strtrim(tline(13:16))},...
                       'altLoc',{strtrim(tline(17))},...
                       'resName',{strtrim(tline(18:20))},...
                       'chainID',{tline(22)},...
                       'resSeq',{str2int(tline(23:26))},...
                       'iCode',{strtrim(tline(27))},...
                       'X',{str2float(tline(31:38))},...
                       'Y',{str2float(tline(39:46))},...
                       'Z',{str2float(tline(47:54))},...
                       'occupancy',{str2int(tline(55:60))},...
                       'tempFactor',{str2float(tline(61:66))},...
                       'segID',{tline(73:76)},...
                       'element',{strtrim(tline(77:78))},...
                       'charge',{tline(79:80)},...
                       'AtomNameStruct',struct('chemSymbol',{strtrim(tline(13:14))},...
                                               'remoteInd',{strtrim(tline(15))},...
                                               'branch',{strtrim(tline(16))})); %#ok<*AGROW>

            %Multiple/Optional
        case 'SIGATM'
            modelWithAtomSD = true;
            NumOfAtomSD = NumOfAtomSD+1;
            TmpAtomSDStruct(NumOfAtomSD) = ...
                struct('AtomSerNo',{str2double(tline(7:11))},...
                'AtomName',{tline(13:16)},...
                'altLoc',{tline(17)},...
                'resName',{tline(18:20)},...
                'chainID',{tline(22)},...
                'resSeq',{str2double(tline(23:26))},...
                'iCode',{tline(27)},...
                'sigX',{str2double(tline(31:38))},...
                'sigY',{str2double(tline(39:46))},...
                'sigZ',{str2double(tline(47:54))},...
                'sigOcc',{str2double(tline(55:60))},...
                'sigTemp',{str2double(tline(61:66))},...
                'segID',{tline(73:76)},...
                'element',{tline(77:78)},...
                'charge',{tline(79:80)},...
                'AtomNameStruct',struct('chemSymbol',{strtrim(tline(13:14))},...
                                        'remoteInd',{strtrim(tline(15))},...
                                        'branch',{strtrim(tline(16))}));

            %Multiple/Optional
        case 'ANISOU'
            modelWithAnisoTemp = true;
            NumOfAnisotropicTemp = NumOfAnisotropicTemp+1;
            TmpAnisoTempStruct(NumOfAnisotropicTemp) = ...
                struct('AtomSerNo',{str2double(tline(7:11))},...
                       'AtomName',{tline(13:16)},...
                       'altLoc',{tline(17)},...
                       'resName',{tline(18:20)},...
                       'chainID',{tline(22)},...
                       'resSeq',{str2double(tline(23:26))},...
                       'iCode',{tline(27)},...
                       'U00',{str2double(tline(29:35))},...
                       'U11',{str2double(tline(36:42))},...
                       'U22',{str2double(tline(43:49))},...
                       'U01',{str2double(tline(50:56))},...
                       'U02',{str2double(tline(57:63))},...
                       'U12',{str2double(tline(64:70))},...
                       'segID',{tline(73:76)},...
                       'element',{tline(77:78)},...
                       'charge',{tline(79:80)},...
                       'AtomNameStruct',struct('chemSymbol',{strtrim(tline(13:14))},...
                                               'remoteInd',{strtrim(tline(15))},...
                                               'branch',{strtrim(tline(16))}));

            %Multiple/Optional
        case 'SIGUIJ'
            modelWithAnisoTempSD = true;
            NumOfAnisotropicTempSD = NumOfAnisotropicTempSD+1;
            TmpAnisoTempSDStruct(NumOfAnisotropicTempSD) = ...
                struct('AtomSerNo',{str2double(tline(7:11))},...
                       'AtomName',{tline(13:16)},...
                       'altLoc',{tline(17)},...
                       'resName',{tline(18:20)},...
                       'chainID',{tline(22)},...
                       'resSeq',{str2double(tline(23:26))},...
                       'iCode',{tline(27)},...
                       'SIG11',{str2double(tline(29:35))},...
                       'SIG22',{str2double(tline(36:42))},...
                       'SIG33',{str2double(tline(43:49))},...
                       'SIG12',{str2double(tline(50:56))},...
                       'SIG13',{str2double(tline(57:63))},...
                       'SIG23',{str2double(tline(64:70))},...
                       'segID',{tline(73:76)},...
                       'element',{tline(77:78)},...
                       'charge',{tline(79:80)},...
                       'AtomNameStruct',struct('chemSymbol',{strtrim(tline(13:14))},...
                                               'remoteInd',{strtrim(tline(15))},...
                                               'branch',{strtrim(tline(16))}));

            % Group/Optional
        case 'TER'
            modelWithTerminal = true;
            NumOfTerminal = NumOfTerminal + 1;
                TmpTerStruct(NumOfTerminal) = ...
                struct('SerialNo',{str2double(tline(7:11))},...
                       'resName',{strtrim(tline(18:20))},...
                       'chainID',{strtrim(tline(22))},...
                       'resSeq',{str2double(tline(23:26))},...
                       'iCode',{strtrim(tline(27))});

            %Multiple Continued/Optional
        case 'HETATM'
            modelWithHetAtom = true;
            NumOfHeterogenAtom = NumOfHeterogenAtom+1;
                TmpHetStruct(NumOfHeterogenAtom) = ...
                struct('AtomSerNo',{str2int(tline(7:11))},...
                       'AtomName',{strtrim(tline(13:16))},...
                       'altLoc',{strtrim(tline(17))},...
                       'resName',{strtrim(tline(18:20))},...
                       'chainID',{tline(22)},...
                       'resSeq',{str2double(tline(23:26))},...
                       'iCode',{strtrim(tline(27))},...
                       'X',{str2double(tline(31:38))},...
                       'Y',{str2double(tline(39:46))},...
                       'Z',{str2double(tline(47:54))},...
                       'occupancy',{str2double(tline(55:60))},...
                       'tempFactor',{str2double(tline(61:66))},...
                       'segID',{tline(73:76)},...
                       'element',{strtrim(tline(77:78))},...
                       'charge',{tline(79:80)},...
                       'AtomNameStruct',struct('chemSymbol',{strtrim(tline(13:14))},...
                                               'remoteInd',{strtrim(tline(15))},...
                                               'branch',{strtrim(tline(16))}));
            % Group/Optional
        case 'ENDMDL'
            % End of model
            pdb_out.Model(NumOfModel).MDLSerNo = ModelSerNum;
            if modelWithAtom
                pdb_out.Model(NumOfModel).Atom = TmpAtomStruct;
                modelWithAtom = false;
                TmpAtomStruct = allocateAtoms;
            end
            if modelWithAtomSD
                pdb_out.Model(NumOfModel).AtomSD = TmpAtomSDStruct;
                modelWithAtomSD = false;
                TmpAtomSDStruct = allocateAtomSD;
            end
            if modelWithAnisoTemp
                pdb_out.Model(NumOfModel).AnisotropicTemp = TmpAnisoTempStruct;
                modelWithAnisoTemp = false;
                TmpAnisoTempStruct = allocateAnisoTemp;
            end
            if modelWithAnisoTempSD
                pdb_out.Model(NumOfModel).AnisotropicTempSD = TmpAnisoTempSDStruct;
                modelWithAnisoTempSD = false;
                TmpAnisoTempSDStruct = allocateAnisoTempSD;
            end
            if modelWithTerminal
                pdb_out.Model(NumOfModel).Terminal = TmpTerStruct;
                modelWithTerminal = false;
                TmpTerStruct = allocateTerminal;
            end
            if modelWithHetAtom
                pdb_out.Model(NumOfModel).HeterogenAtom = TmpHetStruct;
                modelWithHetAtom = false;
                TmpHetStruct = allocateAtoms;
            end
            %Multiple/Optional
        case 'CONECT'
            NumOfConnectivity = NumOfConnectivity+1;
            temp_a = str2double(tline(7:11));
            temp_b = GetAtomList(tline(12:31));
            temp_c = GetAtomList([tline(32:41) char(32) tline(47:56)]);
            temp_d = GetAtomList([tline(42:46) char(32) tline(57:61)]);
            pdb_out.Connectivity (NumOfConnectivity) = ...
                struct('AtomSerNo',{temp_a},...
                       'BondAtomList',{temp_b},...
                       'HydrogenAtomList',{temp_c},...
                       'SaltBridgeAtom',{temp_d});

            %Single/Mandatory
        case 'MASTER'
            pdb_out.Master = struct('numREMARK',{str2double(tline(11:15))},...
                                       'numHET',{str2double(tline(21:25))},...
                                       'numHelix',{str2double(tline(26:30))},...
                                       'numSheet',{str2double(tline(31:35))},...
                                       'numTurn',{str2double(tline(36:40))},...
                                       'numSite',{str2double(tline(41:45))},...
                                       'numXform',{str2double(tline(46:50))},...
                                       'numCoord',{str2double(tline(51:55))},...
                                       'numTer',{str2double(tline(56:60))},...
                                       'numConect',{str2double(tline(61:65))},...
                                       'numSeq',{str2double(tline(66:70))});

            %Single/Mandatory
        case 'END'
            % Found end of file

            %Multiple/Optional
        case 'FTNOTE'
            FtnoteNo = str2double(tline(7:10));
            CurFtnote = FtnoteNo;
            tmpFtnote = sprintf('%d',CurFtnote);

            if CurFtnote ~= PrevFtnote
                pdb_out.(['Footnote' tmpFtnote]) = tline(12:70);
                PrevFtnote = CurFtnote;
            else
                pdb_out.(['Footnote' tmpFtnote])  = ...
                    strvcat(pdb_out.(['Footnote' tmpFtnote]) ,tline(12:70)); %#ok
            end

        otherwise
            %disp('The file contains invalid record type');

    end % for the SWITCH statement

end % for the WHILE loop

% If one of the following flags is still true then no 'ENDMDL' (End of
% Model) line  has been found, this means that the file only contains one
% model and we still need to assign the temporal structures to the output
% structure:
if modelWithAtom
    pdb_out.Model.Atom = TmpAtomStruct;
end
if modelWithAtomSD
    pdb_out.Model.AtomSD = TmpAtomSDStruct;
end
if modelWithAnisoTemp
    pdb_out.Model.AnisotropicTemp = TmpAnisoTempStruct;
end
if modelWithAnisoTempSD
    pdb_out.Model.AnisotropicTempSD = TmpAnisoTempSDStruct;
end
if modelWithTerminal
    pdb_out.Model.Terminal = TmpTerStruct;
end
if modelWithHetAtom
    pdb_out.Model.HeterogenAtom = TmpHetStruct;
end

function OutList = GetAtomList(InString)
str = strtrim(InString);
OutList = [];
if ~isempty(str)
    try
        OutList = sscanf(str,'%d')';
    catch allExceptions %#ok<NASGU>
        OutList = [];
    end
end
function OutAcid = GetSequence(InAcid)
% Residues in pdbfiles are arranged every four columns, there are three
% cases:
% 1. Residues are three letter code aminoacids:
%    Ex: SEQRES 1 A 21 GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU
% 2. Residues are deoxyribonucleotides:
%    Ex: SEQRES 1 A 8   DA  DA  DC  DC  DG  DG  DT  DT
% 3. Residues are ribonucleotides:
%    Ex: SEQRES 1 X 39   U   C   C   C   C   C   G   U   G   C   C   C   A

if all(isspace(InAcid(2:4:end)))
    OutAcid = strtrim(InAcid(3:4:end));
    return
elseif all(isspace(InAcid(1:4:end)))
    OutAcid = strtrim(InAcid(3:4:end));
    return
end

OutAcid = strrep(upper(InAcid),'ALA','a');
OutAcid = strrep(OutAcid,'ARG','r');
OutAcid = strrep(OutAcid,'ASN','n');
OutAcid = strrep(OutAcid,'ASP','d');
OutAcid = strrep(OutAcid,'ASX','b');
OutAcid = strrep(OutAcid,'CYS','c');
OutAcid = strrep(OutAcid,'GLN','q');
OutAcid = strrep(OutAcid,'GLU','e');
OutAcid = strrep(OutAcid,'GLX','z');
OutAcid = strrep(OutAcid,'GLY','g');
OutAcid = strrep(OutAcid,'HIS','h');
OutAcid = strrep(OutAcid,'ILE','i');
OutAcid = strrep(OutAcid,'LEU','l');
OutAcid = strrep(OutAcid,'LYS','k');
OutAcid = strrep(OutAcid,'MET','m');
OutAcid = strrep(OutAcid,'PHE','f');
OutAcid = strrep(OutAcid,'PRO','p');
OutAcid = strrep(OutAcid,'SER','s');
OutAcid = strrep(OutAcid,'THR','t');
OutAcid = strrep(OutAcid,'TRP','w');
OutAcid = strrep(OutAcid,'TYR','y');
OutAcid = strrep(OutAcid,'VAL','v');
OutAcid = strrep(OutAcid,'UNK','x');
OutAcid = regexprep(OutAcid,'[A-Z][A-Z][A-Z]','?');
OutAcid = upper(OutAcid(~isspace(OutAcid)));

%---------------------------------------------------------------%
function [OutStruct,OutNum] = GetResidueStruct(TmpStruct,InString,InNum)

a=1; b=10;
sz = size(InString);
while b <= sz(2)
    test_str = InString(a:b);
    InNum = InNum + 1;
    TmpStruct(InNum).ResName = test_str(1:3);
    TmpStruct(InNum).ChainID = test_str(5);
    TmpStruct(InNum).ResSeqNo = str2double(test_str(6:9));
    TmpStruct(InNum).InsCode = test_str(10);
    a=a+11;
    b=b+11;
end
OutNum = InNum;
OutStruct = TmpStruct;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function filename = savetempfile(pdbtext)

filename =  [tempname '.spt'];
fid=fopen(filename,'wb');

rows = size(pdbtext,1);

for rcount=1:rows-1,
    fprintf(fid,'%s\n',pdbtext(rcount,:));
end

fprintf(fid,'%s',pdbtext(rows,:));
fclose(fid);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function val = str2int(str)
val = sscanf(str,'%d');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function val = str2float(str)
val = sscanf(str,'%e');

%------------------------------------------------------------------%
function Atom = allocateAtoms
% Initialize Model.Atom, HeterogeneAtom structures
% % Atom = struct('GlobalSerNo',{0},...
Atom = struct('AtomSerNo',{0},...
              'AtomName',{''},...
              'altLoc',{''},...
              'resName',{''},...
              'chainID',{''},...
              'resSeq',{0},...
              'iCode',{''},...
              'X',{0},...
              'Y',{0},...
              'Z',{0},...
              'occupancy',{0},...
              'tempFactor',{0},...
              'segID',{''},...
              'element',{''},...
              'charge',{''},...
              'AtomNameStruct',struct('chemSymbol',{''},...
                                      'remoteInd',{''},...
                                      'branch',{''}));
%-----------------------------------------------------------------%                                  
function Terminal = allocateTerminal
% Initialize Model.Terminal structure
Terminal = struct('SerialNo',{},...
                  'resName',{},...
                  'chainID',{},...
                  'resSeq',{0},...
                  'iCode',{});
              
%-------------------------------------------------------------------%
function AtomSD = allocateAtomSD
% Initialize Model.AtomSD
AtomSD = struct('AtomSerNo',{},...
                'AtomName',{},...
                'altLoc',{},...
                'resName',{},...
                'chainID',{},...
                'resSeq',{0},...
                'iCode',{},...
                'sigX',{0},...
                'sigY',{0},...
                'sigZ',{0},...
                'sigOcc',{0},...
                'sigTemp',{0},...
                'segID',{},...
                'element',{},...
                'charge',{},...
                'AtomNameStruct',struct('chemSymbol',{},...
                                        'remoteInd',{},...
                                        'branch',{}));
                                    
%-------------------------------------------------------------------%
function AnisoTemp = allocateAnisoTemp
% Initialize Model.AnisoTemp
AnisoTemp = struct('AtomSerNo',{0},...
                       'AtomName',{},...
                       'altLoc',{},...
                       'resName',{},...
                       'chainID',{},...
                       'resSeq',{0},...
                       'iCode',{},...
                       'U00',{0},...
                       'U11',{0},...
                       'U22',{0},...
                       'U01',{0},...
                       'U02',{0},...
                       'U12',{0},...
                       'segID',{},...
                       'element',{},...
                       'charge',{},...
                       'AtomNameStruct',struct('chemSymbol',{},...
                                               'remoteInd',{},...
                                               'branch',{}));
%-------------------------------------------------------------------%
function AnisoTempSD = allocateAnisoTempSD
% Initialize Model.AnisoTempSD
AnisoTempSD = struct('AtomSerNo',{0},...
                       'AtomName',{},...
                       'altLoc',{},...
                       'resName',{},...
                       'chainID',{},...
                       'resSeq',{0},...
                       'iCode',{},...
                       'SIG11',{0},...
                       'SIG22',{0},...
                       'SIG33',{0},...
                       'SIG12',{0},...
                       'SIG13',{0},...
                       'SIG23',{0},...
                       'segID',{},...
                       'element',{},...
                       'charge',{},...
                       'AtomNameStruct',struct('chemSymbol',{},...
                                               'remoteInd',{},...
                                               'branch',{}));
